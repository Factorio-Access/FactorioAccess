---Rail Describer
---
---Analyzes rails and produces descriptions for user-facing announcements.
---Works with scripts/rails/announcer.lua and locale/en/rail-announcer.cfg

require("polyfill")

local RailData = require("railutils.rail-data")
local RailInfo = require("railutils.rail-info")
local Queries = require("railutils.queries")
local TurnTable = require("railutils.turn-table")
local Traverser = require("railutils.traverser")

local mod = {}

---@class railutils.JunctionDescription
---@field direction defines.direction The end direction facing this junction
---@field kind railutils.JunctionKind Type of junction (split, fork-left, fork-right, fork-both)

---@class railutils.RailDescription
---@field kind railutils.RailKind Descriptive kind (e.g., "horizontal", "top-of-east-to-north-turn")
---@field end_direction defines.direction|nil Direction of disconnected end if any
---@field lonely boolean True if no extensions exist
---@field junctions railutils.JunctionDescription[] Array of junctions (0-2), sorted by direction

---Check if a specific rail exists at a position on the surface
---@param surface railutils.RailsSurface
---@param position fa.Point
---@param expected_rail_type railutils.RailType
---@param expected_direction defines.direction
---@return boolean
local function has_rail_at(surface, position, expected_rail_type, expected_direction)
   local rails = surface:get_rails_at_point(position)

   for _, rail in ipairs(rails) do
      -- Check type, direction, AND that the rail is actually at this position
      -- (get_rails_at_point returns rails whose bounding box overlaps the tile,
      -- so we need to verify the rail's actual position matches)
      if
         rail.rail_type == expected_rail_type
         and rail.direction == expected_direction
         and math.floor(rail.prototype_position.x) == math.floor(position.x)
         and math.floor(rail.prototype_position.y) == math.floor(position.y)
      then
         return true
      end
   end
   return false
end

---Map from (direction % 8) to RailKind for straight rails
---Opposite directions differ by 8, so mod 8 collapses them to same value
---Only straight rails are classified; curves handled separately
---@type table<number, railutils.RailKind>
local SIMPLE_RAIL_MAP = {
   [0] = RailInfo.RailKind.VERTICAL, -- north/south
   [1] = RailInfo.RailKind.NORTHNORTHEAST, -- NNE/SSW
   [2] = RailInfo.RailKind.NORTHEAST, -- NE/SW
   [3] = RailInfo.RailKind.EASTNORTHEAST, -- ENE/WSW
   [4] = RailInfo.RailKind.HORIZONTAL, -- east/west
   [5] = RailInfo.RailKind.EASTSOUTHEAST, -- ESE/WNW
   [6] = RailInfo.RailKind.SOUTHEAST, -- SE/NW
   [7] = RailInfo.RailKind.SOUTHSOUTHEAST, -- SSE/NNW
}

---Classify straight and half-diagonal rails
---@param rail_type railutils.RailType
---@param placement_direction defines.direction
---@return railutils.RailKind|nil Kind string or nil if not a simple rail
local function classify_simple_rail(rail_type, placement_direction)
   if rail_type ~= RailInfo.RailType.STRAIGHT and rail_type ~= RailInfo.RailType.HALF_DIAGONAL then return nil end

   local ends = Queries.get_end_directions(rail_type, placement_direction)
   local dir_mod_8 = ends[1] % 8
   local rail_kind = SIMPLE_RAIL_MAP[dir_mod_8]

   -- Validate rail type matches expected type for this direction
   -- STRAIGHT: even directions (0, 2, 4, 6) - cardinals and diagonals
   -- HALF_DIAGONAL: odd directions (1, 3, 5, 7) - half-diagonals
   if rail_type == RailInfo.RailType.STRAIGHT and (dir_mod_8 % 2 == 0) then
      return rail_kind
   elseif rail_type == RailInfo.RailType.HALF_DIAGONAL and (dir_mod_8 % 2 == 1) then
      return rail_kind
   end

   return nil
end

---90-degree turn detection table (imported from turn-table.lua)
---Generated by extract-turn-table.lua
local TURN_TABLE = TurnTable
if not TURN_TABLE then error("TURN_TABLE is nil - turn-table.lua import failed!") end

---Check if a turn exists by verifying the other pieces
---Uses Traverser to simulate walking the turn and checking if rails exist
---@param surface railutils.RailsSurface
---@param rail_type railutils.RailType Starting rail type
---@param placement_direction defines.direction Starting placement direction
---@param position fa.Point Starting position (grid-adjusted)
---@param end_dir defines.direction Which end to start from
---@param turn_dir number 1 for right, -1 for left
---@param count number Number of turns to verify
---@return boolean
local function verify_turn_exists(surface, rail_type, placement_direction, position, end_dir, turn_dir, count)
   if count == 0 then return true end

   local trav = Traverser.new(rail_type, position, placement_direction, end_dir)

   for i = 1, count do
      if turn_dir > 0 then
         trav:move_right()
      else
         trav:move_left()
      end

      if not has_rail_at(surface, trav:get_position(), trav:get_rail_kind(), trav:get_placement_direction()) then
         return false
      end
   end

   return true
end

---Try to detect 90-degree turn for a curved rail
---@param surface railutils.RailsSurface
---@param rail_type railutils.RailType
---@param placement_direction defines.direction
---@param position fa.Point
---@return railutils.RailKind|nil Turn description or nil if not a turn
local function detect_turn(surface, rail_type, placement_direction, position)
   if rail_type ~= RailInfo.RailType.CURVE_A and rail_type ~= RailInfo.RailType.CURVE_B then return nil end

   local turn_info = TURN_TABLE[rail_type] and TURN_TABLE[rail_type][placement_direction]
   if not turn_info then return nil end

   -- Verify both forward and backward directions (if counts > 0)
   if turn_info.verify_forward.count > 0 then
      if
         not verify_turn_exists(
            surface,
            rail_type,
            placement_direction,
            position,
            turn_info.verify_forward.end_dir,
            turn_info.verify_forward.turn_dir,
            turn_info.verify_forward.count
         )
      then
         return nil
      end
   end

   if turn_info.verify_back.count > 0 then
      if
         not verify_turn_exists(
            surface,
            rail_type,
            placement_direction,
            position,
            turn_info.verify_back.end_dir,
            turn_info.verify_back.turn_dir,
            turn_info.verify_back.count
         )
      then
         return nil
      end
   end

   -- Both verifications passed (or had count=0)
   local from_name = Queries.get_cardinal_name(turn_info.from_cardinal) or "north"
   local to_name = Queries.get_cardinal_name(turn_info.to_cardinal) or "south"

   return turn_info.position .. "-of-" .. from_name .. "-to-" .. to_name .. "-turn"
end

---Direct lookup table for curved-rail-a fallback descriptions
---@type table<defines.direction, railutils.RailKind>
local CURVE_A_FALLBACK = {
   [defines.direction.north] = RailInfo.RailKind.LEFT_OF_NORTH,
   [defines.direction.northeast] = RailInfo.RailKind.RIGHT_OF_NORTH,
   [defines.direction.east] = RailInfo.RailKind.LEFT_OF_EAST,
   [defines.direction.southeast] = RailInfo.RailKind.RIGHT_OF_EAST,
   [defines.direction.south] = RailInfo.RailKind.LEFT_OF_SOUTH,
   [defines.direction.southwest] = RailInfo.RailKind.RIGHT_OF_SOUTH,
   [defines.direction.west] = RailInfo.RailKind.LEFT_OF_WEST,
   [defines.direction.northwest] = RailInfo.RailKind.RIGHT_OF_WEST,
}

---Direct lookup table for curved-rail-b fallback descriptions
---@type table<defines.direction, railutils.RailKind>
local CURVE_B_FALLBACK = {
   [defines.direction.north] = RailInfo.RailKind.RIGHT_OF_SOUTHEAST,
   [defines.direction.northeast] = RailInfo.RailKind.LEFT_OF_SOUTHWEST,
   [defines.direction.east] = RailInfo.RailKind.RIGHT_OF_SOUTHWEST,
   [defines.direction.southeast] = RailInfo.RailKind.LEFT_OF_NORTHWEST,
   [defines.direction.south] = RailInfo.RailKind.RIGHT_OF_NORTHWEST,
   [defines.direction.southwest] = RailInfo.RailKind.LEFT_OF_NORTHEAST,
   [defines.direction.west] = RailInfo.RailKind.RIGHT_OF_NORTHEAST,
   [defines.direction.northwest] = RailInfo.RailKind.LEFT_OF_SOUTHEAST,
}

---Junction classification lookup: [has_straight][has_left][has_right] -> JunctionKind
---@type table<boolean, table<boolean, table<boolean, railutils.JunctionKind?>>>
local JUNCTION_CLASSIFICATION = {
   [false] = {
      [true] = { [true] = RailInfo.JunctionKind.SPLIT },
   },
   [true] = {
      [false] = { [true] = RailInfo.JunctionKind.FORK_RIGHT },
      [true] = {
         [false] = RailInfo.JunctionKind.FORK_LEFT,
         [true] = RailInfo.JunctionKind.FORK_BOTH,
      },
   },
}

---Get fallback description for curved rails
---@param rail_type railutils.RailType
---@param placement_direction defines.direction
---@return railutils.RailKind
local function get_curve_fallback(rail_type, placement_direction)
   if rail_type == RailInfo.RailType.CURVE_A then
      local kind = CURVE_A_FALLBACK[placement_direction]
      if kind then return kind end
   end

   if rail_type == RailInfo.RailType.CURVE_B then
      local kind = CURVE_B_FALLBACK[placement_direction]
      if kind then return kind end
   end

   error("Unknown rail type or placement direction for curve fallback")
end

---Describe a rail on a surface
---@param surface railutils.RailsSurface Surface to query for connected rails
---@param rail_type railutils.RailType Type of rail to describe
---@param placement_direction defines.direction Direction the rail is placed
---@param position fa.Point Position of the rail (grid-adjusted)
---@return railutils.RailDescription
function mod.describe_rail(surface, rail_type, placement_direction, position)
   local description = {
      kind = "",
      end_direction = nil,
      lonely = false,
      junctions = {},
   }

   -- Try simple classification first
   local simple_kind = classify_simple_rail(rail_type, placement_direction)
   if simple_kind then
      description.kind = simple_kind
   else
      -- For curves, try turn detection first
      local turn_kind = detect_turn(surface, rail_type, placement_direction, position)
      if turn_kind then
         description.kind = turn_kind
      else
         -- Fall back to simple left/right of cardinal/diagonal
         description.kind = get_curve_fallback(rail_type, placement_direction)
      end
   end

   -- Get the two ends of this rail
   local ends = Queries.get_end_directions(rail_type, placement_direction)

   -- Track connections: map from end_direction to array of connected extensions
   local connected_extensions = {}
   local total_connected = 0

   for _, end_dir in ipairs(ends) do
      local extensions = Queries.get_extensions_from_end(position, rail_type, placement_direction, end_dir)
      connected_extensions[end_dir] = {}

      for _, ext in ipairs(extensions) do
         -- Check if expected rail exists at this extension point
         local expected_rail_type = Queries.prototype_type_to_rail_type(ext.next_rail_prototype)
         if has_rail_at(surface, ext.next_rail_position, expected_rail_type, ext.next_rail_direction) then
            table.insert(connected_extensions[end_dir], ext)
            total_connected = total_connected + 1
         end
      end
   end

   -- Determine if lonely
   description.lonely = (total_connected == 0)

   -- Determine disconnected end
   for _, end_dir in ipairs(ends) do
      if #connected_extensions[end_dir] == 0 then
         description.end_direction = end_dir
         break
      end
   end

   -- Determine junctions (splits and forks)
   for end_dir, exts in pairs(connected_extensions) do
      if #exts >= 2 then
         -- This end has multiple connections - check which directions exist
         local has_straight = false
         local has_left = false
         local has_right = false

         for _, ext in ipairs(exts) do
            local offset = (ext.goal_direction - end_dir + 16) % 16
            if offset == 0 then
               has_straight = true
            elseif offset == 1 then
               has_right = true
            elseif offset == 15 then
               has_left = true
            end
         end

         -- Classify the junction based on which directions exist
         local junction_kind = JUNCTION_CLASSIFICATION[has_straight]
            and JUNCTION_CLASSIFICATION[has_straight][has_left]
            and JUNCTION_CLASSIFICATION[has_straight][has_left][has_right]

         -- Only add if it's a recognized junction type (ignore single connections)
         if junction_kind then
            table.insert(description.junctions, {
               direction = end_dir,
               kind = junction_kind,
            })
         end
      end
   end

   -- Sort junctions by direction
   table.sort(description.junctions, function(a, b)
      return a.direction < b.direction
   end)

   return description
end

return mod
