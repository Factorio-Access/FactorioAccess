--Here: Functions related to ghosts, blueprints and blueprint books
--Does not include event handlers

local BuildingTools = require("scripts.building-tools")
local FaUtils = require("scripts.fa-utils")
local Graphics = require("scripts.graphics")
local Speech = require("scripts.speech")
local PlayerMiningTools = require("scripts.player-mining-tools")
local UiRouter = require("scripts.ui.router")
local Viewpoint = require("scripts.viewpoint")

local dirs = defines.direction

local mod = {}

--todo cleanup blueprint calls in control.lua so that blueprint data editing calls happen only within this module

function mod.get_bp_data_for_edit(stack)
   ---@diagnostic disable-next-line: param-type-mismatch
   return helpers.json_to_table(helpers.decode_string(string.sub(stack.export_stack(), 2)))
end

--Works for blueprints and also books too
function mod.set_stack_bp_from_data(stack, bp_data)
   stack.import_stack("0" .. helpers.encode_string(helpers.table_to_json(bp_data)))
end

function mod.set_blueprint_description(stack, description)
   local bp_data = mod.get_bp_data_for_edit(stack)
   bp_data.blueprint.description = description
   mod.set_stack_bp_from_data(stack, bp_data)
end

function mod.get_blueprint_description(stack)
   local bp_data = mod.get_bp_data_for_edit(stack)
   local desc = bp_data.blueprint.description
   if desc == nil then desc = "" end
   return desc
end

function mod.set_blueprint_label(stack, label)
   local bp_data = mod.get_bp_data_for_edit(stack)
   bp_data.blueprint.label = label
   mod.set_stack_bp_from_data(stack, bp_data)
end

function mod.get_blueprint_label(stack)
   local bp_data = mod.get_bp_data_for_edit(stack)
   local label = bp_data.blueprint.label
   if label == nil then label = "no name" end
   return label
end

--Create a blueprint from a rectangle between any two points and give it to the player's hand
function mod.create_blueprint(pindex, point_1, point_2, prior_bp_data)
   local top_left, bottom_right = FaUtils.get_top_left_and_bottom_right(point_1, point_2)
   local p = game.get_player(pindex)
   if prior_bp_data ~= nil then
      --First clear the bp in hand
      p.cursor_stack.set_stack({ name = "blueprint", count = 1 })
   end
   if
      not p.cursor_stack.valid_for_read
      or p.cursor_stack.valid_for_read
         and not (p.cursor_stack.is_blueprint and p.cursor_stack.is_blueprint_setup() == false and prior_bp_data == nil)
   then
      local cleared = p.clear_cursor()
      if not cleared then
         Speech.speak({ "fa.blueprints-error-cursor-full" }, pindex)
         return
      end
   end
   p.cursor_stack.set_stack({ name = "blueprint" })
   p.cursor_stack.create_blueprint({ surface = p.surface, force = p.force, area = { top_left, bottom_right } })

   --Avoid empty blueprints
   local ent_count = p.cursor_stack.get_blueprint_entity_count()
   if ent_count == 0 then
      if prior_bp_data == nil then p.cursor_stack.set_stack({ name = "blueprint" }) end
      local message = Speech.new()
      message:fragment({ "fa.blueprints-selection-empty" })
      if prior_bp_data ~= nil then message:fragment({ "fa.blueprints-keeping-old" }) end
      Speech.speak(message:build(), pindex)
   else
      local prior_name = ""
      if prior_bp_data ~= nil then prior_name = prior_bp_data.blueprint.label or "" end
      local message = Speech.new()
      message:fragment({ "fa.blueprints-created", prior_name })
      message:fragment(FaUtils.format_count(ent_count, { "fa.blueprints-entities" }))
      message:fragment({ "fa.blueprints-in-hand" })
      Speech.speak(message:build(), pindex)
   end

   --Copy label and description and icons from previous version
   if prior_bp_data ~= nil then
      local bp_data = mod.get_bp_data_for_edit(p.cursor_stack)
      bp_data.blueprint.label = prior_bp_data.blueprint.label or ""
      bp_data.blueprint.label_color = prior_bp_data.blueprint.label_color or { 1, 1, 1 }
      bp_data.blueprint.description = prior_bp_data.blueprint.description or ""
      bp_data.blueprint.icons = prior_bp_data.blueprint.icons or {}
      if ent_count == 0 then bp_data.blueprint.entities = prior_bp_data.blueprint.entities end
      mod.set_stack_bp_from_data(p.cursor_stack, bp_data)
   end

   --Use this opportunity to update saved information about the blueprint's corners (used when drawing the footprint)
   local width, height = mod.get_blueprint_width_and_height(pindex)
   storage.players[pindex].blueprint_width_in_hand = width + 1
   storage.players[pindex].blueprint_height_in_hand = height + 1
end

--Building function for bluelprints
function mod.paste_blueprint(pindex)
   local p = game.get_player(pindex)
   local bp = p.cursor_stack
   local vp = Viewpoint.get_viewpoint(pindex)
   local pos = vp:get_cursor_pos()

   --Not a blueprint
   if bp.is_blueprint == false then return nil end
   --Empty blueprint
   if not bp.is_blueprint_setup() then return nil end

   --Get the offset blueprint positions
   local left_top, right_bottom, build_pos = mod.get_blueprint_corners(pindex, false)

   --Clear build area for objects up to a certain range, while others are marked for deconstruction
   PlayerMiningTools.clear_obstacles_in_rectangle(left_top, right_bottom, pindex, 99)

   --Build it and check if successful
   local dir = storage.players[pindex].blueprint_hand_direction
   local result = bp.build_blueprint({
      surface = p.surface,
      force = p.force,
      position = build_pos,
      direction = dir,
      by_player = p,
      force_build = false,
   })
   if result == nil or #result == 0 then
      p.play_sound({ path = "utility/cannot_build" })
      --Explain build error
      local build_area = { left_top, right_bottom }
      local result = BuildingTools.identify_building_obstacle(pindex, build_area, nil)
      Speech.speak(result, pindex)
      return false
   else
      p.play_sound({ path = "Close-Inventory-Sound" }) --laterdo maybe better blueprint placement sound
      Speech.speak({ "fa.blueprints-placed", mod.get_blueprint_label(bp) }, pindex)
      return true
   end
end

--Returns the left top and right bottom corners of the blueprint, as well as the center position
function mod.get_blueprint_corners(pindex, draw_rect)
   local p = game.get_player(pindex)
   local bp = p.cursor_stack
   if bp == nil or bp.valid_for_read == false or bp.is_blueprint == false then error("invalid call. no blueprint") end
   local vp = Viewpoint.get_viewpoint(pindex)
   local pos = vp:get_cursor_pos()
   local ents = bp.get_blueprint_entities() or {}
   local west_most_x = 0
   local east_most_x = 0
   local north_most_y = 0
   local south_most_y = 0
   local first_ent = true
   --Empty blueprint: Just report the tile of the cursor
   if bp.is_blueprint_setup() == false then
      local left_top = { x = math.floor(pos.x), y = math.floor(pos.y) }
      local right_bottom = { x = math.ceil(pos.x), y = math.ceil(pos.y) }
      return left_top, right_bottom, pos
   end

   --Find the blueprint borders and corners
   for i, ent in ipairs(ents) do
      local ent_width = prototypes.entity[ent.name].tile_width
      local ent_height = prototypes.entity[ent.name].tile_height
      if ent.direction == dirs.east or ent.direction == dirs.west then
         ent_width = prototypes.entity[ent.name].tile_height
         ent_height = prototypes.entity[ent.name].tile_width
      end
      --Find the edges of this ent
      local ent_north = ent.position.y - math.floor(ent_height / 2)
      local ent_east = ent.position.x + math.floor(ent_width / 2)
      local ent_south = ent.position.y + math.floor(ent_height / 2)
      local ent_west = ent.position.x - math.floor(ent_width / 2)
      --Initialize with this entity
      if first_ent then
         first_ent = false
         west_most_x = ent_west
         east_most_x = ent_east
         north_most_y = ent_north
         south_most_y = ent_south
      else
         --Compare ent edges with the blueprint edges
         if west_most_x > ent_west then west_most_x = ent_west end
         if east_most_x < ent_east then east_most_x = ent_east end
         if north_most_y > ent_north then north_most_y = ent_north end
         if south_most_y < ent_south then south_most_y = ent_south end
      end
   end
   --Determine blueprint dimensions from the final edges
   local bp_left_top = { x = math.floor(west_most_x), y = math.floor(north_most_y) }
   local bp_right_bottom = { x = math.ceil(east_most_x), y = math.ceil(south_most_y) }
   local bp_width = bp_right_bottom.x - bp_left_top.x - 1
   local bp_height = bp_right_bottom.y - bp_left_top.y - 1
   if
      storage.players[pindex].blueprint_hand_direction == dirs.east
      or storage.players[pindex].blueprint_hand_direction == dirs.west
   then
      --Flip width and height
      bp_width = bp_right_bottom.y - bp_left_top.y - 1
      bp_height = bp_right_bottom.x - bp_left_top.x - 1
   end
   local left_top = { x = math.floor(pos.x), y = math.floor(pos.y) }
   local right_bottom = { x = math.ceil(pos.x + bp_width), y = math.ceil(pos.y + bp_height) }

   --Draw the build preview (default is false)
   if draw_rect == true then
      --Draw a temporary rectangle for debugging
      rendering.draw_rectangle({
         left_top = left_top,
         right_bottom = right_bottom,
         color = { r = 0.25, b = 0.25, g = 1.0, a = 0.75 },
         width = 2,
         draw_on_ground = true,
         surface = p.surface,
         players = nil,
         time_to_live = 100,
      })
   end

   --Get the mouse pointer position
   local mouse_pos = { x = pos.x + bp_width / 2, y = pos.y + bp_height / 2 }

   return left_top, right_bottom, mouse_pos
end

--Returns: bp_width, bp_height
function mod.get_blueprint_width_and_height(pindex)
   local p = game.get_player(pindex)
   local bp = p.cursor_stack
   if bp == nil or bp.valid_for_read == false or bp.is_blueprint == false then
      bp = game.get_player(pindex).get_main_inventory()[storage.players[pindex].inventory.index]
   end
   if bp == nil or bp.valid_for_read == false or bp.is_blueprint == false then return nil, nil end
   local vp = Viewpoint.get_viewpoint(pindex)
   local pos = vp:get_cursor_pos()
   local ents = bp.get_blueprint_entities()
   local west_most_x = 0
   local east_most_x = 0
   local north_most_y = 0
   local south_most_y = 0
   local first_ent = true

   --Empty blueprint
   if not ents or bp.is_blueprint_setup() == false then return 0, 0 end

   --Find the blueprint borders and corners
   for i, ent in ipairs(ents) do
      local ent_width = prototypes.entity[ent.name].tile_width
      local ent_height = prototypes.entity[ent.name].tile_height
      if ent.direction == dirs.east or ent.direction == dirs.west then
         ent_width = prototypes.entity[ent.name].tile_height
         ent_height = prototypes.entity[ent.name].tile_width
      end
      --Find the edges of this ent
      local ent_north = ent.position.y - math.floor(ent_height / 2)
      local ent_east = ent.position.x + math.floor(ent_width / 2)
      local ent_south = ent.position.y + math.floor(ent_height / 2)
      local ent_west = ent.position.x - math.floor(ent_width / 2)
      --Initialize with this entity
      if first_ent then
         first_ent = false
         west_most_x = ent_west
         east_most_x = ent_east
         north_most_y = ent_north
         south_most_y = ent_south
      else
         --Compare ent edges with the blueprint edges
         if west_most_x > ent_west then west_most_x = ent_west end
         if east_most_x < ent_east then east_most_x = ent_east end
         if north_most_y > ent_north then north_most_y = ent_north end
         if south_most_y < ent_south then south_most_y = ent_south end
      end
   end
   --Determine blueprint dimensions from the final edges
   local bp_left_top = { x = math.floor(west_most_x), y = math.floor(north_most_y) }
   local bp_right_bottom = { x = math.ceil(east_most_x), y = math.ceil(south_most_y) }
   local bp_width = bp_right_bottom.x - bp_left_top.x - 1
   local bp_height = bp_right_bottom.y - bp_left_top.y - 1
   if
      storage.players[pindex].blueprint_hand_direction == dirs.east
      or storage.players[pindex].blueprint_hand_direction == dirs.west
   then
      --Flip width and height
      bp_width = bp_right_bottom.y - bp_left_top.y - 1
      bp_height = bp_right_bottom.x - bp_left_top.x - 1
   end
   return bp_width, bp_height
end

--Export and import the same blueprint so that its parameters reset, e.g. rotation.
function mod.refresh_blueprint_in_hand(pindex)
   local p = game.get_player(pindex)
   if p.cursor_stack.is_blueprint_setup() == false then return end
   local bp_data = mod.get_bp_data_for_edit(p.cursor_stack)
   mod.set_stack_bp_from_data(p.cursor_stack, bp_data)
end

--Basic info for when the blueprint item is read.
function mod.get_blueprint_info(stack, in_hand, pindex)
   --Not a blueprint
   if stack.is_blueprint == false then return "" end
   --Empty blueprint
   if not stack.is_blueprint_setup() then return "Blueprint empty" end

   --Get name
   local name = mod.get_blueprint_label(stack)
   if name == nil then name = "" end
   --Construct result
   local result = { "", { "fa.blueprints-name-features", name } }
   if in_hand then result = { "", { "fa.blueprints-name-in-hand-features", name } } end
   --Use icons as extra info (in case it is not named)
   local icons = stack.preview_icons
   if icons == nil or #icons == 0 then
      result = { "", result, { "fa.blueprints-no-details" } }
      return result
   end

   for i, signal in ipairs(icons) do
      if signal.index > 1 then result = { "", result, { "fa.blueprints-and" } } end
      if signal.signal.name ~= nil then
         result = { "", result, signal.signal.name } --***todo localise
      else
         result = { "", result, { "fa.blueprints-unknown-icon" } }
      end
   end

   result = { "", result, { "fa.blueprints-entities-total", tostring(stack.get_blueprint_entity_count()) } }

   --Use this opportunity to update saved information about the blueprint's corners (used when drawing the footprint)
   if in_hand then
      local width, height = mod.get_blueprint_width_and_height(pindex)
      if width == nil or height == nil then return result end
      storage.players[pindex].blueprint_width_in_hand = width + 1
      storage.players[pindex].blueprint_height_in_hand = height + 1
   end
   return result
end

function mod.get_blueprint_icons_info(bp_table)
   local result = { "" }
   --Use icons as extra info (in case it is not named)
   local icons = bp_table.icons
   if icons == nil or #icons == 0 then
      result = { "", result, { "fa.blueprints-no-icons" } }
      return result
   end

   for i, signal in ipairs(icons) do
      if signal.index > 1 then result = { "", result, { "fa.blueprints-and" } } end
      if signal.signal.name ~= nil then
         result = { "", result, signal.signal.name }
      else
         result = { "", result, { "fa.blueprints-unknown-icon" } }
      end
   end
   return result
end

function mod.apply_blueprint_import(pindex, text)
   local bp = game.get_player(pindex).cursor_stack
   --local result = bp.import_stack("0"..text)
   local result = bp.import_stack(text)
   if result == 0 then
      if bp.is_blueprint then
         Speech.speak({ "fa.blueprints-imported-successfully", mod.get_blueprint_label(bp) }, pindex)
      elseif bp.is_blueprint_book then
         Speech.speak({ "fa.blueprints-imported-book" }, pindex)
      else
         Speech.speak({ "fa.blueprints-imported-unknown" }, pindex)
      end
   elseif result == -1 then
      if bp.is_blueprint then
         Speech.speak({ "fa.blueprints-imported-with-errors", mod.get_blueprint_label(bp) }, pindex)
      elseif bp.is_blueprint_book then
         Speech.speak({ "fa.blueprints-imported-book-errors" }, pindex)
      else
         Speech.speak({ "fa.blueprints-imported-unknown-errors" }, pindex)
      end
   else --result == 1
      Speech.speak({ "fa.blueprints-import-failed" }, pindex)
   end
end

function mod.blueprint_menu_open(pindex)
   if storage.players[pindex].vanilla_mode then return end

   UiRouter.get_router(pindex):open_ui(UiRouter.UI_NAMES.BLUEPRINT)

   storage.players[pindex].move_queue = {}

   --Set the menu line counter to 0
   storage.players[pindex].blueprint_menu = {
      index = 0,
      edit_label = false,
      edit_description = false,
      edit_export = false,
      edit_import = false,
   }

   --Play sound
   game.get_player(pindex).play_sound({ path = "Open-Inventory-Sound" })
end

function mod.blueprint_menu_close(pindex, mute_in)
   local mute = mute_in
   --Set the player menu tracker to none
   UiRouter.get_router(pindex):close_ui()

   --Set the menu line counter to 0
   storage.players[pindex].blueprint_menu.index = 0

   --play sound
   if not mute then game.get_player(pindex).play_sound({ path = "Close-Inventory-Sound" }) end

   --Destroy text fields
   if game.get_player(pindex).gui.screen["blueprint-edit-label"] ~= nil then
      game.get_player(pindex).gui.screen["blueprint-edit-label"].destroy()
   end
   if game.get_player(pindex).gui.screen["blueprint-edit-description"] ~= nil then
      game.get_player(pindex).gui.screen["blueprint-edit-description"].destroy()
   end
   if game.get_player(pindex).gui.screen["blueprint-edit-export"] ~= nil then
      game.get_player(pindex).gui.screen["blueprint-edit-export"].destroy()
   end
   if game.get_player(pindex).gui.screen["blueprint-edit-import"] ~= nil then
      game.get_player(pindex).gui.screen["blueprint-edit-import"].destroy()
   end
   if game.get_player(pindex).opened ~= nil then game.get_player(pindex).opened = nil end
end

function mod.get_bp_book_data_for_edit(stack)
   ---@diagnostic disable-next-line: param-type-mismatch
   return helpers.json_to_table(helpers.decode_string(string.sub(stack.export_stack(), 2)))
end

--We run the export rarely because it eats UPS
function mod.set_bp_book_data_from_cursor(pindex)
   local cursor_stack = game.get_player(pindex).cursor_stack
   storage.players[pindex].blueprint_book_menu.book_data = mod.get_bp_book_data_for_edit(cursor_stack)
end

function mod.blueprint_book_get_label(pindex)
   local bp_data = storage.players[pindex].blueprint_book_menu.book_data
   local label = bp_data.blueprint_book.label
   if label == nil then label = "" end
   return label
end

function mod.blueprint_book_set_label(pindex, new_name)
   local p = game.get_player(pindex)
   local bp_data = storage.players[pindex].blueprint_book_menu.book_data
   bp_data.blueprint_book.label = new_name
   mod.set_stack_bp_from_data(p.cursor_stack, bp_data)
end

--Basic info for when the blueprint book item is read.
function mod.get_blueprint_book_info(stack, in_hand)
   --Not a book
   if stack == nil or stack.is_blueprint_book == false then return "" end

   --Get data
   local book_data = mod.get_bp_book_data_for_edit(stack)
   local label = book_data.blueprint_book.label
   if label == nil then label = "" end
   local item_count = mod.blueprint_book_data_get_item_count(book_data)

   --Construct result
   local result = { "" }
   table.insert(result, "Blueprint book ")
   table.insert(result, label)
   if in_hand then table.insert(result, " in hand") end
   table.insert(result, ", ")
   table.insert(result, { "fa.blueprints-with-items", tostring(item_count) })

   return result
end

function mod.get_blueprint_book_description(stack)
   local bp_data = mod.get_bp_book_data_for_edit(stack)
   local desc = bp_data.blueprint_book.description
   if desc == nil then desc = "" end
   return desc
end

function mod.set_blueprint_book_description(pindex, new_name)
   local p = game.get_player(pindex)
   local bp_data = storage.players[pindex].blueprint_book_menu.book_data
   bp_data.blueprint_book.description = new_name
   mod.set_stack_bp_from_data(p.cursor_stack, bp_data)
end

function mod.blueprint_book_get_item_count(pindex)
   local bp_data = storage.players[pindex].blueprint_book_menu.book_data
   local items = bp_data.blueprint_book.blueprints
   if items == nil or items == {} then
      return 0
   else
      return #items
   end
end

function mod.blueprint_book_data_get_item_count(book_data)
   local items = book_data.blueprint_book.blueprints
   if items == nil or items == {} then
      return 0
   else
      return #items
   end
end

--Reads a blueprint within the blueprint book
function mod.blueprint_book_read_item(pindex, i)
   local bp_data = storage.players[pindex].blueprint_book_menu.book_data
   local items = bp_data.blueprint_book.blueprints
   return items[i]["blueprint"]
end

--Puts the book away and imports the selected blueprint to hand
function mod.blueprint_book_copy_item_to_hand(pindex, i)
   local bp_data = storage.players[pindex].blueprint_book_menu.book_data
   local items = bp_data.blueprint_book.blueprints
   local item_string = "0" .. helpers.encode_string(helpers.table_to_json(items[i]))

   local p = game.get_player(pindex)
   p.clear_cursor()
   p.cursor_stack.import_stack(item_string)
   p.cursor_stack_temporary = true
   Speech.speak({ "fa.blueprints-copied-to-hand" }, pindex)
end

--WIP: Remove a blueprint from a selected blueprint book, based on the index
function mod.blueprint_book_take_out_item(pindex, index)
   --laterdo ***
end

--WIP: Add a selected blueprint to a selected blueprint book
function mod.blueprint_book_add_item(pindex, bp)
   --laterdo ***
end

local BLUEPRINT_BOOK_SETTINGS_MENU_LENGTH = 8

--[[ Blueprint book menu options summary
   List Mode (Press LEFT BRACKET on the BPB in hand)
   0. name, menu instructions
   X. Read/copy/take out blueprint number X

   Settings Mode (Press RIGHT BRACKET on the BPB in hand)
   0. name, bp count, menu instructions
   1. Read the description
   2. Read the icons, which are its featured components
   3. Rename this book
   4. Edit the description
   5. Create a copy of this blueprint book
   6. Delete this blueprint book (press twice)
   7. Export this blueprint book as a text string
   Later: 8. Import a blueprint or book from a text string

   Note: BPB normally supports description and icons, but it is unclear whether the json tables can access these.
]]
function mod.run_blueprint_book_menu(pindex, menu_index, list_mode, left_clicked, right_clicked)
   local index = menu_index
   local p = game.get_player(pindex)
   if not (p.cursor_stack and p.cursor_stack.valid_for_read and p.cursor_stack.is_blueprint_book) then return end
   ---@type LuaItemStack
   local bpb = p.cursor_stack
   local item_count = mod.blueprint_book_get_item_count(pindex)
   --Update menu length
   storage.players[pindex].blueprint_book_menu.menu_length = BLUEPRINT_BOOK_SETTINGS_MENU_LENGTH
   if list_mode then storage.players[pindex].blueprint_book_menu.menu_length = item_count end

   --Run menu
   if list_mode then
      local book_inv = bpb.get_inventory(defines.inventory.item_main) --**TODO use this for more accurate and efficient reading
      --Blueprint book list mode
      if index == 0 then
         --stuff
         local message = Speech.new()
         message:fragment({ "fa.blueprints-browsing-book", mod.blueprint_book_get_label(pindex) })
         message:fragment({ "fa.blueprints-with-items", tostring(item_count) })
         message:fragment({ "fa.blueprints-book-navigation" })
         Speech.speak(message:build(), pindex)
      else
         --Examine items (empty slots are skipped)
         local item = mod.blueprint_book_read_item(pindex, index)
         local name = ""
         if item == nil or item.item == nil then
            name = { "fa.blueprints-unknown-item-index", tostring(index) }
         elseif item.item == "blueprint" then
            local label = item.label
            if label == nil then label = "" end
            name = { "", { "fa.blueprints-blueprint-featuring", label }, mod.get_blueprint_icons_info(item) }
         else
            name = { "fa.blueprints-unknown-item-type", item.item }
         end
         if left_clicked == false and right_clicked == false then
            --Read blueprint info
            local result = name
            Speech.speak(result, pindex)
         elseif left_clicked == true and right_clicked == false then
            --Copy the blueprint to hand
            if item == nil or item.item == nil then
               Speech.speak({ "fa.blueprints-cannot-get" }, pindex)
            elseif item.item == "blueprint" or item.item == "blueprint-book" then
               mod.blueprint_book_copy_item_to_hand(pindex, index)
            else
               Speech.speak({ "fa.blueprints-cannot-get" }, pindex)
            end
         elseif left_clicked == false and right_clicked == true then
            --Take the blueprint to hand (Therefore both copy and delete)
            --...
         end
      end
   else
      --Blueprint book settings mode
      if index == 0 then
         Speech.speak(
            "Settings for blueprint book "
               .. mod.blueprint_book_get_label(pindex)
               .. ", with "
               .. item_count
               .. " items,"
               .. " Press 'W' and 'S' to navigate options, press 'LEFT BRACKET' to select, press 'E' to exit this menu.",
            pindex
         )
      elseif index == 1 then
         if left_clicked ~= true then
            local result = "Read the description of this blueprint book"
            Speech.speak(result, pindex)
         else
            local result = mod.get_blueprint_book_description(bpb)
            if result == nil or result == "" then result = "no description" end
            Speech.speak(result, pindex)
         end
      elseif index == 2 then
         if left_clicked ~= true then
            local result = "Read the icons of this blueprint book, which are its featured components"
            Speech.speak(result, pindex)
         else
            local result = "This book features "
            if bpb.preview_icons and #bpb.preview_icons > 0 then
               --Icon 1
               if bpb.preview_icons[1] ~= nil then result = result .. bpb.preview_icons[1].signal.name .. ", " end
               if bpb.preview_icons[2] ~= nil then result = result .. bpb.preview_icons[2].signal.name .. ", " end
               if bpb.preview_icons[3] ~= nil then result = result .. bpb.preview_icons[3].signal.name .. ", " end
               if bpb.preview_icons[4] ~= nil then result = result .. bpb.preview_icons[4].signal.name .. ", " end
            else
               result = result .. "nothing"
            end
            Speech.speak(result, pindex)
         end
      elseif index == 3 then
         if left_clicked ~= true then
            local result = "Rename this book"
            Speech.speak(result, pindex)
         else
            storage.players[pindex].blueprint_menu.edit_label = true
            local frame = Graphics.create_text_field_frame(pindex, "blueprint-edit-label")
            local result =
               "Type in a new name for this blueprint and press 'ENTER' to confirm, or press 'ESC' to cancel."
            Speech.speak(result, pindex)
         end
      elseif index == 4 then
         if left_clicked ~= true then
            local result = "Rewrite the description of this book"
            Speech.speak(result, pindex)
         else
            storage.players[pindex].blueprint_menu.edit_description = true
            local frame = Graphics.create_text_field_frame(pindex, "blueprint-edit-description")
            local result =
               "Type in the new description text box for this blueprint and press 'ENTER' to confirm, or press 'ESC' to cancel."
            Speech.speak(result, pindex)
         end
      elseif index == 5 then
         if left_clicked ~= true then
            local result = "Create a copy of this blueprint book"
            Speech.speak(result, pindex)
         else
            p.insert(table.deepcopy(bpb))
            local result = "Book copy inserted to inventory"
            Speech.speak(result, pindex)
         end
      elseif index == 6 then
         if left_clicked ~= true then
            local result = "Delete this blueprint book"
            Speech.speak(result, pindex)
         else
            bpb.set_stack({ name = "blueprint", count = 1 })
            bpb.set_stack(nil) --calls event handler to delete empty planners.
            local result = "Blueprint book deleted and menu closed"
            Speech.speak(result, pindex)
            mod.blueprint_menu_close(pindex)
         end
      elseif index == 7 then
         if left_clicked ~= true then
            local result = "Export this blueprint book as a text string"
            Speech.speak(result, pindex)
         else
            storage.players[pindex].blueprint_menu.edit_export = true
            local frame = Graphics.create_text_field_frame(pindex, "blueprint-edit-export", bpb.export_stack())
            local result =
               "Copy the text from this box using 'CONTROL + A' and then 'CONTROL + C' and then press ENTER to exit"
            Speech.speak(result, pindex)
         end
      elseif index == 8 then
         --Import a text string to overwrite this blueprint book
         if left_clicked ~= true then
            local result = "Import a text string to overwrite this blueprint book"
            Speech.speak(result, pindex)
         else
            storage.players[pindex].blueprint_menu.edit_import = true
            local frame = Graphics.create_text_field_frame(pindex, "blueprint-edit-import")
            local result = "Paste a copied blueprint text string in this box and then press ENTER to load it"
            Speech.speak(result, pindex)
         end
      end
   end
end

function mod.blueprint_book_menu_open(pindex, open_in_list_mode)
   if storage.players[pindex].vanilla_mode then return end
   UiRouter.get_router(pindex):open_ui(UiRouter.UI_NAMES.BLUEPRINT_BOOK)
   storage.players[pindex].move_queue = {}

   --Set the menu line counter to 0
   storage.players[pindex].blueprint_book_menu = {
      book_data = nil,
      index = 0,
      menu_length = 0,
      list_mode = open_in_list_mode,
      edit_label = false,
      edit_description = false,
      edit_export = false,
      edit_import = false,
   }

   --Set the data
   mod.set_bp_book_data_from_cursor(pindex)

   --Play sound
   game.get_player(pindex).play_sound({ path = "Open-Inventory-Sound" })

   --Load menu
   local bpb_menu = storage.players[pindex].blueprint_book_menu
   mod.run_blueprint_book_menu(pindex, bpb_menu.index, bpb_menu.list_mode, false, false)
end

function mod.blueprint_book_menu_close(pindex, mute_in)
   local mute = mute_in
   --Set the player menu tracker to none
   UiRouter.get_router(pindex):close_ui()

   --Set the menu line counter to 0
   storage.players[pindex].blueprint_book_menu.index = 0

   --play sound
   if not mute then game.get_player(pindex).play_sound({ path = "Close-Inventory-Sound" }) end

   --Destroy text fields
   if game.get_player(pindex).gui.screen["blueprint-book-edit-label"] ~= nil then
      game.get_player(pindex).gui.screen["blueprint-book-edit-label"].destroy()
   end
   if game.get_player(pindex).gui.screen["blueprint-book-edit-description"] ~= nil then
      game.get_player(pindex).gui.screen["blueprint-book-edit-description"].destroy()
   end
   if game.get_player(pindex).gui.screen["blueprint-book-edit-export"] ~= nil then
      game.get_player(pindex).gui.screen["blueprint-book-edit-export"].destroy()
   end
   if game.get_player(pindex).gui.screen["blueprint-book-edit-import"] ~= nil then
      game.get_player(pindex).gui.screen["blueprint-book-edit-import"].destroy()
   end
   if game.get_player(pindex).opened ~= nil then game.get_player(pindex).opened = nil end
end

function mod.blueprint_book_menu_up(pindex)
   storage.players[pindex].blueprint_book_menu.index = storage.players[pindex].blueprint_book_menu.index - 1
   if storage.players[pindex].blueprint_book_menu.index < 0 then
      storage.players[pindex].blueprint_book_menu.index = 0
      game.get_player(pindex).play_sound({ path = "inventory-edge" })
   else
      --Play sound
      game.get_player(pindex).play_sound({ path = "Inventory-Move" })
   end
   --Load menu
   local bpb_menu = storage.players[pindex].blueprint_book_menu
   mod.run_blueprint_book_menu(pindex, bpb_menu.index, bpb_menu.list_mode, false, false)
end

function mod.blueprint_book_menu_down(pindex)
   storage.players[pindex].blueprint_book_menu.index = storage.players[pindex].blueprint_book_menu.index + 1
   if storage.players[pindex].blueprint_book_menu.index > storage.players[pindex].blueprint_book_menu.menu_length then
      storage.players[pindex].blueprint_book_menu.index = storage.players[pindex].blueprint_book_menu.menu_length
      game.get_player(pindex).play_sound({ path = "inventory-edge" })
   else
      --Play sound
      game.get_player(pindex).play_sound({ path = "Inventory-Move" })
   end
   --Load menu
   local bpb_menu = storage.players[pindex].blueprint_book_menu
   mod.run_blueprint_book_menu(pindex, bpb_menu.index, bpb_menu.list_mode, false, false)
end

--Finds the first empty index for the blueprint book
local function get_first_empty_book_index(book_data)
   local items = book_data.blueprint_book.blueprints
   if items == nil then return 0 end
   for i = 0, #items + 1, 1 do
      local i_found = false
      for j, item in ipairs(items) do
         if item.index == i then i_found = true end
      end
      if i_found == false then return i end
   end
   return #items
end

--Used to explore how blueprint/book info tables work
function mod.print_book_slots(book_stack)
   local book_data = mod.get_bp_book_data_for_edit(book_stack)
   local items = book_data.blueprint_book.blueprints
   if items == nil then
      game.print("Empty book.", { volume_modifier = 0 })
      return
   end
   for i = 1, 18, 1 do
      if items[i] == nil then
         game.print(i .. ": NIL slot: ", { volume_modifier = 0 })
      elseif items[i] == {} then
         game.print(i .. ": Empty table slot: ", { volume_modifier = 0 })
      elseif items[i].blueprint ~= nil then
         game.print(i .. ": Slot with 'blueprint', index: " .. items[i]["index"], { volume_modifier = 0 })
         local bp = items[i].blueprint
         if bp.item == nil then
            game.print(i .. ": item: No item", { volume_modifier = 0 })
         else
            game.print(i .. ": item: " .. bp.item, { volume_modifier = 0 })
         end
      elseif items[i].index == nil then
         game.print(i .. ": Slot with unknown case, NO index", { volume_modifier = 0 })
      else
         game.print(i .. ": Slot with non-bp item, index: " .. items[i]["index"], { volume_modifier = 0 })
      end
   end
end

function mod.add_blueprint_to_book(pindex, book_stack, bp_stack)
   local p = game.get_player(pindex)
   local bp_data = mod.get_bp_data_for_edit(bp_stack)
   local book_data = mod.get_bp_book_data_for_edit(book_stack)
   local items = book_data.blueprint_book.blueprints
   local item_count = mod.blueprint_book_data_get_item_count(book_data)
   if item_count == 0 then items = {} end
   local new_item = {}
   local new_slot_id = get_first_empty_book_index(book_data)
   new_item["index"] = new_slot_id
   new_item["blueprint"] = bp_data.blueprint
   items[item_count + 1] = new_item
   book_data.blueprint_book.blueprints = items
   mod.set_stack_bp_from_data(book_stack, book_data)
   Speech.speak({ "fa.blueprints-added-to-book-index", tostring(new_slot_id) }, pindex)
end

--Uses the array index and not the book index
function mod.remove_item_from_book(pindex, book_stack, array_index)
   local p = game.get_player(pindex)
   local book_data = mod.get_bp_book_data_for_edit(book_stack)
   local items = book_data.blueprint_book.blueprints
   items[array_index] = nil
   book_data.blueprint_book.blueprints = items
   mod.set_stack_bp_from_data(book_stack, book_data)
   Speech.speak({ "fa.blueprints-item-removed" }, pindex)
end

function mod.copy_selected_area_to_clipboard(pindex, point_1, point_2)
   local top_left, bottom_right = FaUtils.get_top_left_and_bottom_right(point_1, point_2)
   local p = game.get_player(pindex)
   if p.cursor_stack == nil or p.cursor_stack.valid_for_read == false then return end
   p.cursor_stack.set_stack({ name = "blueprint", count = 1 })
   p.cursor_stack.create_blueprint({ surface = p.surface, force = p.force, area = { top_left, bottom_right } })
   if
      not (
         p.cursor_stack
         and p.cursor_stack.valid_for_read
         and p.cursor_stack.is_blueprint
         and p.cursor_stack.is_blueprint_setup()
      )
   then
      p.clear_cursor()
      p.cursor_stack.set_stack({ name = "copy-paste-tool", count = 1 })
      Speech.speak({ "fa.blueprints-copied-nothing" }, pindex)
      return
   end
   p.add_to_clipboard(p.cursor_stack)
   p.clear_cursor()
   p.activate_paste()

   --Use this opportunity to update saved information about the blueprint's corners (used when drawing the footprint)
   local width, height = mod.get_blueprint_width_and_height(pindex)
   storage.players[pindex].blueprint_width_in_hand = width + 1
   storage.players[pindex].blueprint_height_in_hand = height + 1
end

return mod
